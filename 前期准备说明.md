# 前期准备

---

## 1. 仓库架构方案：单一组织下的多模块 Mono-repo

### 推荐目录结构

建议建立一个名为 `ai-auditor-core` 的主仓库，结构如下：

```text
ai-auditor-core/
├── services/
│   ├── parser-rs/          # 成员 A (Rust): 高性能解析
│   ├── engine-java/        # 成员 B (Java): 业务规则库
│   ├── inference-py/       # 成员 C (Python): Qwen 模型推理
│   └── gateway-go/         # 成员 D (Go): 分布式调度网关
├── shared/
│   └── protos/             # 重点：所有成员共用的 gRPC 接口定义 (.proto)
├── scripts/                # 胶水脚本与自动化工具
└── docker-compose.yml      # 一键启动所有服务的配置

```

---

## 2. 成员技术栈集成：包管理器与构建策略

### 👤 成员 A (Rust - `cargo`)

* **任务：** 使用 `cargo build --release` 将解析模块编译为二进制文件或 `shared library` (.so/.dll)。
* **交互：** 暴露 **gRPC 接口**，让 Rust 成为高性能的数据源。

### 👤 成员 B (Java - `maven/gradle`)

* **任务：** 负责复杂的规则逻辑。对于 Java，使用 **Maven** 。
* **集成：** 通过 `protobuf-maven-plugin` 自动根据 `shared/protos` 生成 Java 调用类。

### 👤 成员 C (Python - `uv`)

* **任务：** 使用 **`uv`**（目前 Python 最快的包管理器）管理虚拟环境和模型依赖。
* **集成：** 封装 FastAPI 接口，供成员 D 调用。

### 👤 成员 D (Go - `go mod`)

* **任务：** 使用 **Go 模块** 编写调度网关。
* **集成：** 作为“胶水中心”，利用 Go 的并发特性，通过 gRPC 协议同时向 A、B、C 发起请求。

---

## 3. 项目管理：分布式治理 + 统一通信

### **核心方案：gRPC + Docker Compose**

1. **通信层：** 使用 **gRPC (Protobuf)** 替代 JSON。成员 D (Go) 负责调用 A、B、C。
2. **整合层：** 使用 **Docker Compose**。

* 每个人在各自目录下编写一个 `Dockerfile`。
* 根目录下的 `docker-compose.yml` 负责定义各容器的内部网络（如 `parser:50051`, `inference:8000`）。

1. **CI/CD：** 利用 GitHub Actions。当成员 A 修改了 Rust 代码，Actions 只触发 `services/parser-rs` 的镜像构建。

---

## 4. 成员协作工作流 (Git Workflow)

为了防止代码冲突，采用 **GitHub Flow**：

* **Protected Main Branch：** 只有通过测试的代码才能合并到主分支。
* **Feature Branches：** 成员 A 在 `feat/rust-parser` 分支工作，成员 C 在 `feat/qwen-inference` 分支工作。
* **Schema First：** 成员 D 必须先在 `shared/protos` 中定义好接口协议，其他三人才开始编写代码。

---
